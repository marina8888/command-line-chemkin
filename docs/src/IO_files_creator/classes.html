<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>src.IO_files_creator.classes API documentation</title>
<meta name="description" content="This file generates the input conditions that are parsed into the .inp file. This .inp file is the input file for the solver used in job.sh.
The input …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>src.IO_files_creator.classes</code></h1>
</header>
<section id="section-intro">
<p>This file generates the input conditions that are parsed into the .inp file. This .inp file is the input file for the solver used in job.sh.
The input conditions change for every run/new set of experimental conditions that are numerically simulated.
This file takes in a values from 'Sheet1' of conditions, given a spreadsheet using template.xls format as included in the /notes directory.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
This file generates the input conditions that are parsed into the .inp file. This .inp file is the input file for the solver used in job.sh.
The input conditions change for every run/new set of experimental conditions that are numerically simulated.
This file takes in a values from &#39;Sheet1&#39; of conditions, given a spreadsheet using template.xls format as included in the /notes directory.
&#34;&#34;&#34;
import pandas as pd
import numpy as np
import os.path
import re


class InpGenerator():

    def __init__(self, path_to_spreadsheet: str, path_to_inp_file: str):
        &#34;&#34;&#34;
        Takes in an input of a spreadsheet of conditions and returns a folder of chemkin input files.
        :param path_to_spreadsheet: input data spreadsheet file path
        :param path_to_inp_file: input file path
        &#34;&#34;&#34;
        self.sheet = path_to_spreadsheet
        self.inp = path_to_inp_file
        self.inp_name = os.path.basename(path_to_inp_file)
        self.content = []

        # get df and check it for errors:
        self.df = self.sheet_to_df()
        self.check_df_col()

        # get file names for naming:
        self.get_name()

        # create a folder of input files:
        self.create_new_inp(6)

    def sheet_to_df(self):
        &#34;&#34;&#34;
        Create dataframe from spreadsheet file, with a column for each parameter/input. Rejects excel files with duplicate columns.
        spreadsheet column headers and data types must be as documented/shown in notes excel template, and should be first filled with user&#39;s input conditions
        :param: None
        :return df: DataFrame
        &#34;&#34;&#34;
        df = pd.read_excel(self.sheet, sheet_name=&#39;Sheet1&#39;)
        print(&#34;Reading input values from &#39;Sheet1&#39; of your excel spreadsheet...&#34;)
        dup_cols: pd.Series = (df.columns[df.columns.duplicated(keep=False)])
        if dup_cols.empty == False:
            raise AssertionError(&#39;these duplicate columns need renaming: &#39; + str(dup_cols))

        return df

    def check_df_col(self):
        &#34;&#34;&#34;
        Function to check that DataFrame has all the information (and in the right format). Will raise errors if there are any issues with the data.
        This includes any #REF #ERR type cells in the spreadsheet and wrongly typed cells. Also checks all columns contain positive integers.
        :return: None
        &#34;&#34;&#34;
        bad_type = self.df.loc[:, self.df.dtypes != np.float64]
        bad_type = bad_type.loc[:, bad_type.dtypes != np.int64]

        if bad_type.empty is False:
            raise NameError(&#39;Columns: &#39; + str(bad_type.dtypes) + &#39; contain non-integer values&#39;)
        if self.df.isnull().values.any():
            raise NameError(&#39;There are columns with null values in your spreadsheet&#39;)

        for i in self.df.columns:
            if self.df[i].empty:
                raise NameError(&#39;Column &#39; + str(i) + &#39; is empty in your spreadsheet&#39;)

            other_bad_values = np.where(self.df[i] &lt; 0)

            if len(other_bad_values[0]) != 0:
                raise NameError(&#39;Column &#39; + str(i) + &#39; has negative values in your spreadsheet&#39;)

    @staticmethod
    def round_to_nearest(value, base=5):
        return base * round(value / base)

    def get_name(self):
        &#34;&#34;&#34;
        If name1 and name2 columns (which are used for naming solution.out files and filtering data) do not exist,
        create arbitary name1 and name2 columns.
        :return: None
        &#34;&#34;&#34;
        default_names = []
        if not &#39;name1&#39; in self.df.columns or not &#39;name2&#39; in self.df.columns:
            for x in range(0, len(self.df), 1):
                default_names.append(x)
        if not &#39;name1&#39; in self.df.columns:
            self.df[&#39;name1&#39;] = default_names
        if not &#39;name2&#39; in self.df.columns:
            self.df[&#39;name2&#39;] = default_names

    def get_inp_name(self, row: int, round1: int = 2, round2: int = 2):
        &#34;&#34;&#34;
        Creates a name for an input file.
        :param row: spreadsheet row number
        :param round1: rounding value for name1 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
        :param round2: rounding value for name2 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
        :return new_inp_name: a new name for the input file.
        &#34;&#34;&#34;
        new_inp_file_name = &#39;./chemkin_launch_files/input_files/&#39;+ str(round(self.df[&#39;name1&#39;][row], round1)) + &#39;__&#39; + str(
            round(self.df[&#39;name2&#39;][row], round2)) + &#39;__&#39; + self.inp_name
        return new_inp_file_name

    def create_new_inp(self, round_val: int = -1):
        &#34;&#34;&#34;
        A function that generates a new input file based on a dataframe input, where column headers are the variables replaced.
        :param round_val: round input values to a certain number of decimal places.
        :return:
        &#34;&#34;&#34;

        # open old input file and write each line to content:
        with open(self.inp, &#39;rt&#39;) as f:
            self.content = [line.strip() for line in f]

        for row_num in enumerate(self.df.index):
        # look up the spreadsheet column headers in the old inp file, extract the number in the corresponding row following it.
        # Replace this with a new number from a spreadsheet row_num
            name = self.get_inp_name(row_num[0])
            with open(name, &#39;w&#39;) as new_f:

                for l in self.content:
                    for col in enumerate(self.df):
                        if col[1] in l:
                            number_in_text = re.findall(r&#34;\b(\d+(?:\.\d*)?|\.\d+)\b&#34;, l)
                            if len(number_in_text) == 0:
                                raise TypeError(
                                    &#39;please ensure that you have placeholder numerical values in your input file for all variables that you are modifying&#39;)
                            if len(number_in_text) != 1:
                                raise TypeError(
                                    &#39;ensure that inp file only contains one space seperated number per line (which is the variable value).&#39;)
                            if round_val is -1:
                                l = l.replace(&#34; &#34; + number_in_text[0] + &#34; &#34;, &#34; &#34; + str(self.df[col[1]][row_num[0]]) + &#34; &#34;, 1)
                            else:
                                l = l.replace(&#34; &#34; + number_in_text[0] + &#34; &#34;,
                                              &#34; &#34; + str(round(float(self.df[col[1]][row_num[0]]), round_val)) + &#34; &#34;, 1)
                    new_f.write(&#34;\n&#34; + l)
        print(&#39;You can now find the new input files in the .chemkin_launch_files/input_files folder&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="src.IO_files_creator.classes.InpGenerator"><code class="flex name class">
<span>class <span class="ident">InpGenerator</span></span>
<span>(</span><span>path_to_spreadsheet: str, path_to_inp_file: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Takes in an input of a spreadsheet of conditions and returns a folder of chemkin input files.
:param path_to_spreadsheet: input data spreadsheet file path
:param path_to_inp_file: input file path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InpGenerator():

    def __init__(self, path_to_spreadsheet: str, path_to_inp_file: str):
        &#34;&#34;&#34;
        Takes in an input of a spreadsheet of conditions and returns a folder of chemkin input files.
        :param path_to_spreadsheet: input data spreadsheet file path
        :param path_to_inp_file: input file path
        &#34;&#34;&#34;
        self.sheet = path_to_spreadsheet
        self.inp = path_to_inp_file
        self.inp_name = os.path.basename(path_to_inp_file)
        self.content = []

        # get df and check it for errors:
        self.df = self.sheet_to_df()
        self.check_df_col()

        # get file names for naming:
        self.get_name()

        # create a folder of input files:
        self.create_new_inp(6)

    def sheet_to_df(self):
        &#34;&#34;&#34;
        Create dataframe from spreadsheet file, with a column for each parameter/input. Rejects excel files with duplicate columns.
        spreadsheet column headers and data types must be as documented/shown in notes excel template, and should be first filled with user&#39;s input conditions
        :param: None
        :return df: DataFrame
        &#34;&#34;&#34;
        df = pd.read_excel(self.sheet, sheet_name=&#39;Sheet1&#39;)
        print(&#34;Reading input values from &#39;Sheet1&#39; of your excel spreadsheet...&#34;)
        dup_cols: pd.Series = (df.columns[df.columns.duplicated(keep=False)])
        if dup_cols.empty == False:
            raise AssertionError(&#39;these duplicate columns need renaming: &#39; + str(dup_cols))

        return df

    def check_df_col(self):
        &#34;&#34;&#34;
        Function to check that DataFrame has all the information (and in the right format). Will raise errors if there are any issues with the data.
        This includes any #REF #ERR type cells in the spreadsheet and wrongly typed cells. Also checks all columns contain positive integers.
        :return: None
        &#34;&#34;&#34;
        bad_type = self.df.loc[:, self.df.dtypes != np.float64]
        bad_type = bad_type.loc[:, bad_type.dtypes != np.int64]

        if bad_type.empty is False:
            raise NameError(&#39;Columns: &#39; + str(bad_type.dtypes) + &#39; contain non-integer values&#39;)
        if self.df.isnull().values.any():
            raise NameError(&#39;There are columns with null values in your spreadsheet&#39;)

        for i in self.df.columns:
            if self.df[i].empty:
                raise NameError(&#39;Column &#39; + str(i) + &#39; is empty in your spreadsheet&#39;)

            other_bad_values = np.where(self.df[i] &lt; 0)

            if len(other_bad_values[0]) != 0:
                raise NameError(&#39;Column &#39; + str(i) + &#39; has negative values in your spreadsheet&#39;)

    @staticmethod
    def round_to_nearest(value, base=5):
        return base * round(value / base)

    def get_name(self):
        &#34;&#34;&#34;
        If name1 and name2 columns (which are used for naming solution.out files and filtering data) do not exist,
        create arbitary name1 and name2 columns.
        :return: None
        &#34;&#34;&#34;
        default_names = []
        if not &#39;name1&#39; in self.df.columns or not &#39;name2&#39; in self.df.columns:
            for x in range(0, len(self.df), 1):
                default_names.append(x)
        if not &#39;name1&#39; in self.df.columns:
            self.df[&#39;name1&#39;] = default_names
        if not &#39;name2&#39; in self.df.columns:
            self.df[&#39;name2&#39;] = default_names

    def get_inp_name(self, row: int, round1: int = 2, round2: int = 2):
        &#34;&#34;&#34;
        Creates a name for an input file.
        :param row: spreadsheet row number
        :param round1: rounding value for name1 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
        :param round2: rounding value for name2 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
        :return new_inp_name: a new name for the input file.
        &#34;&#34;&#34;
        new_inp_file_name = &#39;./chemkin_launch_files/input_files/&#39;+ str(round(self.df[&#39;name1&#39;][row], round1)) + &#39;__&#39; + str(
            round(self.df[&#39;name2&#39;][row], round2)) + &#39;__&#39; + self.inp_name
        return new_inp_file_name

    def create_new_inp(self, round_val: int = -1):
        &#34;&#34;&#34;
        A function that generates a new input file based on a dataframe input, where column headers are the variables replaced.
        :param round_val: round input values to a certain number of decimal places.
        :return:
        &#34;&#34;&#34;

        # open old input file and write each line to content:
        with open(self.inp, &#39;rt&#39;) as f:
            self.content = [line.strip() for line in f]

        for row_num in enumerate(self.df.index):
        # look up the spreadsheet column headers in the old inp file, extract the number in the corresponding row following it.
        # Replace this with a new number from a spreadsheet row_num
            name = self.get_inp_name(row_num[0])
            with open(name, &#39;w&#39;) as new_f:

                for l in self.content:
                    for col in enumerate(self.df):
                        if col[1] in l:
                            number_in_text = re.findall(r&#34;\b(\d+(?:\.\d*)?|\.\d+)\b&#34;, l)
                            if len(number_in_text) == 0:
                                raise TypeError(
                                    &#39;please ensure that you have placeholder numerical values in your input file for all variables that you are modifying&#39;)
                            if len(number_in_text) != 1:
                                raise TypeError(
                                    &#39;ensure that inp file only contains one space seperated number per line (which is the variable value).&#39;)
                            if round_val is -1:
                                l = l.replace(&#34; &#34; + number_in_text[0] + &#34; &#34;, &#34; &#34; + str(self.df[col[1]][row_num[0]]) + &#34; &#34;, 1)
                            else:
                                l = l.replace(&#34; &#34; + number_in_text[0] + &#34; &#34;,
                                              &#34; &#34; + str(round(float(self.df[col[1]][row_num[0]]), round_val)) + &#34; &#34;, 1)
                    new_f.write(&#34;\n&#34; + l)
        print(&#39;You can now find the new input files in the .chemkin_launch_files/input_files folder&#39;)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="src.IO_files_creator.classes.InpGenerator.round_to_nearest"><code class="name flex">
<span>def <span class="ident">round_to_nearest</span></span>(<span>value, base=5)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def round_to_nearest(value, base=5):
    return base * round(value / base)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="src.IO_files_creator.classes.InpGenerator.check_df_col"><code class="name flex">
<span>def <span class="ident">check_df_col</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to check that DataFrame has all the information (and in the right format). Will raise errors if there are any issues with the data.
This includes any #REF #ERR type cells in the spreadsheet and wrongly typed cells. Also checks all columns contain positive integers.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_df_col(self):
    &#34;&#34;&#34;
    Function to check that DataFrame has all the information (and in the right format). Will raise errors if there are any issues with the data.
    This includes any #REF #ERR type cells in the spreadsheet and wrongly typed cells. Also checks all columns contain positive integers.
    :return: None
    &#34;&#34;&#34;
    bad_type = self.df.loc[:, self.df.dtypes != np.float64]
    bad_type = bad_type.loc[:, bad_type.dtypes != np.int64]

    if bad_type.empty is False:
        raise NameError(&#39;Columns: &#39; + str(bad_type.dtypes) + &#39; contain non-integer values&#39;)
    if self.df.isnull().values.any():
        raise NameError(&#39;There are columns with null values in your spreadsheet&#39;)

    for i in self.df.columns:
        if self.df[i].empty:
            raise NameError(&#39;Column &#39; + str(i) + &#39; is empty in your spreadsheet&#39;)

        other_bad_values = np.where(self.df[i] &lt; 0)

        if len(other_bad_values[0]) != 0:
            raise NameError(&#39;Column &#39; + str(i) + &#39; has negative values in your spreadsheet&#39;)</code></pre>
</details>
</dd>
<dt id="src.IO_files_creator.classes.InpGenerator.create_new_inp"><code class="name flex">
<span>def <span class="ident">create_new_inp</span></span>(<span>self, round_val: int = -1)</span>
</code></dt>
<dd>
<div class="desc"><p>A function that generates a new input file based on a dataframe input, where column headers are the variables replaced.
:param round_val: round input values to a certain number of decimal places.
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_new_inp(self, round_val: int = -1):
    &#34;&#34;&#34;
    A function that generates a new input file based on a dataframe input, where column headers are the variables replaced.
    :param round_val: round input values to a certain number of decimal places.
    :return:
    &#34;&#34;&#34;

    # open old input file and write each line to content:
    with open(self.inp, &#39;rt&#39;) as f:
        self.content = [line.strip() for line in f]

    for row_num in enumerate(self.df.index):
    # look up the spreadsheet column headers in the old inp file, extract the number in the corresponding row following it.
    # Replace this with a new number from a spreadsheet row_num
        name = self.get_inp_name(row_num[0])
        with open(name, &#39;w&#39;) as new_f:

            for l in self.content:
                for col in enumerate(self.df):
                    if col[1] in l:
                        number_in_text = re.findall(r&#34;\b(\d+(?:\.\d*)?|\.\d+)\b&#34;, l)
                        if len(number_in_text) == 0:
                            raise TypeError(
                                &#39;please ensure that you have placeholder numerical values in your input file for all variables that you are modifying&#39;)
                        if len(number_in_text) != 1:
                            raise TypeError(
                                &#39;ensure that inp file only contains one space seperated number per line (which is the variable value).&#39;)
                        if round_val is -1:
                            l = l.replace(&#34; &#34; + number_in_text[0] + &#34; &#34;, &#34; &#34; + str(self.df[col[1]][row_num[0]]) + &#34; &#34;, 1)
                        else:
                            l = l.replace(&#34; &#34; + number_in_text[0] + &#34; &#34;,
                                          &#34; &#34; + str(round(float(self.df[col[1]][row_num[0]]), round_val)) + &#34; &#34;, 1)
                new_f.write(&#34;\n&#34; + l)
    print(&#39;You can now find the new input files in the .chemkin_launch_files/input_files folder&#39;)</code></pre>
</details>
</dd>
<dt id="src.IO_files_creator.classes.InpGenerator.get_inp_name"><code class="name flex">
<span>def <span class="ident">get_inp_name</span></span>(<span>self, row: int, round1: int = 2, round2: int = 2)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a name for an input file.
:param row: spreadsheet row number
:param round1: rounding value for name1 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
:param round2: rounding value for name2 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
:return new_inp_name: a new name for the input file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_inp_name(self, row: int, round1: int = 2, round2: int = 2):
    &#34;&#34;&#34;
    Creates a name for an input file.
    :param row: spreadsheet row number
    :param round1: rounding value for name1 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
    :param round2: rounding value for name2 column (WARNING: too low of a number might overwrite an input file due to duplicate names!)
    :return new_inp_name: a new name for the input file.
    &#34;&#34;&#34;
    new_inp_file_name = &#39;./chemkin_launch_files/input_files/&#39;+ str(round(self.df[&#39;name1&#39;][row], round1)) + &#39;__&#39; + str(
        round(self.df[&#39;name2&#39;][row], round2)) + &#39;__&#39; + self.inp_name
    return new_inp_file_name</code></pre>
</details>
</dd>
<dt id="src.IO_files_creator.classes.InpGenerator.get_name"><code class="name flex">
<span>def <span class="ident">get_name</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>If name1 and name2 columns (which are used for naming solution.out files and filtering data) do not exist,
create arbitary name1 and name2 columns.
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_name(self):
    &#34;&#34;&#34;
    If name1 and name2 columns (which are used for naming solution.out files and filtering data) do not exist,
    create arbitary name1 and name2 columns.
    :return: None
    &#34;&#34;&#34;
    default_names = []
    if not &#39;name1&#39; in self.df.columns or not &#39;name2&#39; in self.df.columns:
        for x in range(0, len(self.df), 1):
            default_names.append(x)
    if not &#39;name1&#39; in self.df.columns:
        self.df[&#39;name1&#39;] = default_names
    if not &#39;name2&#39; in self.df.columns:
        self.df[&#39;name2&#39;] = default_names</code></pre>
</details>
</dd>
<dt id="src.IO_files_creator.classes.InpGenerator.sheet_to_df"><code class="name flex">
<span>def <span class="ident">sheet_to_df</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create dataframe from spreadsheet file, with a column for each parameter/input. Rejects excel files with duplicate columns.
spreadsheet column headers and data types must be as documented/shown in notes excel template, and should be first filled with user's input conditions
:param: None
:return df: DataFrame</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sheet_to_df(self):
    &#34;&#34;&#34;
    Create dataframe from spreadsheet file, with a column for each parameter/input. Rejects excel files with duplicate columns.
    spreadsheet column headers and data types must be as documented/shown in notes excel template, and should be first filled with user&#39;s input conditions
    :param: None
    :return df: DataFrame
    &#34;&#34;&#34;
    df = pd.read_excel(self.sheet, sheet_name=&#39;Sheet1&#39;)
    print(&#34;Reading input values from &#39;Sheet1&#39; of your excel spreadsheet...&#34;)
    dup_cols: pd.Series = (df.columns[df.columns.duplicated(keep=False)])
    if dup_cols.empty == False:
        raise AssertionError(&#39;these duplicate columns need renaming: &#39; + str(dup_cols))

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="src.IO_files_creator" href="index.html">src.IO_files_creator</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="src.IO_files_creator.classes.InpGenerator" href="#src.IO_files_creator.classes.InpGenerator">InpGenerator</a></code></h4>
<ul class="two-column">
<li><code><a title="src.IO_files_creator.classes.InpGenerator.check_df_col" href="#src.IO_files_creator.classes.InpGenerator.check_df_col">check_df_col</a></code></li>
<li><code><a title="src.IO_files_creator.classes.InpGenerator.create_new_inp" href="#src.IO_files_creator.classes.InpGenerator.create_new_inp">create_new_inp</a></code></li>
<li><code><a title="src.IO_files_creator.classes.InpGenerator.get_inp_name" href="#src.IO_files_creator.classes.InpGenerator.get_inp_name">get_inp_name</a></code></li>
<li><code><a title="src.IO_files_creator.classes.InpGenerator.get_name" href="#src.IO_files_creator.classes.InpGenerator.get_name">get_name</a></code></li>
<li><code><a title="src.IO_files_creator.classes.InpGenerator.round_to_nearest" href="#src.IO_files_creator.classes.InpGenerator.round_to_nearest">round_to_nearest</a></code></li>
<li><code><a title="src.IO_files_creator.classes.InpGenerator.sheet_to_df" href="#src.IO_files_creator.classes.InpGenerator.sheet_to_df">sheet_to_df</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>